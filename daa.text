Practical 1 
VIVA QUESTIONS & ANSWERS
Question	Answer
1. What is recursion?	When a function calls itself until a base condition is met.
2. What is Fibonacci series?	A sequence where each term = sum of the previous two terms.
3. What are base conditions in Fibonacci recursion?	F(0) = 0, F(1) = 1
4. Which method is faster â€” recursive or iterative?	Iterative (O(n) time)
5. Why is recursive slow?	Because it recomputes the same values many times (exponential calls).
6. What is time complexity of recursive Fibonacci?	O(2â¿)
7. What is space complexity of recursive Fibonacci?	O(n) due to call stack.
8. What is time complexity of iterative Fibonacci?	O(n)
9. What is space complexity of iterative Fibonacci?	O(1)
10. What is the advantage of recursion?	Simple and clear logic; good for problems with repeated substructure.
11. What is the disadvantage of recursion?	High memory usage and slower execution.
12. What is difference between recursion and iteration?	Recursion uses function calls; iteration uses loops.

Practucal 2
ğŸ§  Step 1: Understanding the Problem â€” What is Huffman Encoding?
ğŸ‘‰ Huffman Encoding is a lossless data compression algorithm.
It reduces the size of data without losing any information.
Used in ZIP, JPEG, MP3, etc.

ğŸ”¹ Example:
Suppose we have a text:
AABBCDEEE
Letâ€™s count the frequency of each character:
Character	Frequency
A	2
B	2
C	1
D	1
E	3
We want to represent this text in binary (0s and 1s).
Normally, if we use 3 bits per character (since 5 chars â†’ need at least 3 bits), we need:
â¡ï¸ 9 characters Ã— 3 bits = 27 bits.
But some characters (like E) appear more often than others,
so we can assign shorter codes to frequent characters,
and longer codes to less frequent ones.
This is where Huffman Encoding comes in!

ğŸ§© Step 2: The Greedy Approach
Huffman follows a Greedy Algorithm â€”
At every step, it picks the two smallest frequency nodes,
and combines them into one.

ğŸ”¹ Steps of Huffman Algorithm
	1. Create a leaf node for each unique character with its frequency.
	2. Insert all nodes into a priority queue (min-heap) ordered by frequency.
	3. While more than one node remains:
		â—‹ Remove the two smallest nodes.
		â—‹ Create a new node with frequency = sum of both.
		â—‹ The two nodes become left (0) and right (1) child.
		â—‹ Insert the new node back into the heap.
	4. The remaining node is the root of the Huffman Tree.
	5. Traverse the tree:
		â—‹ Left edge â†’ add â€˜0â€™
		â—‹ Right edge â†’ add â€˜1â€™
		â—‹ Leaf nodes give the final Huffman codes.

ğŸ”¹ Example: Letâ€™s build it step by step
Symbol	Frequency
A	5
B	9
C	12
D	13
E	16
F	45

Step 1: Take two smallest â†’ A(5) and B(9) â†’ combine â†’ 14
Now new set:
14, 12, 13, 16, 45
Step 2: Take 12 and 13 â†’ combine â†’ 25
New set: 14, 16, 25, 45
Step 3: Take 14 and 16 â†’ combine â†’ 30
New set: 25, 30, 45
Step 4: Take 25 and 30 â†’ combine â†’ 55
New set: 45, 55
Step 5: Take 45 and 55 â†’ combine â†’ 100 â†’ root node

Now assign:
	â€¢ Left edge â†’ 0
	â€¢ Right edge â†’ 1
You get codes like:
Symbol	Huffman Code
F	0
C	100
D	101
A	1100
B	1101
E	111
âœ… Total encoded bits < original bits â†’ compression achieved!

âš™ï¸ Step 3: Why Greedy?
Because Huffman always chooses the two smallest frequencies first â€”
a locally optimal choice that leads to a globally optimal solution
(minimum cost of encoding).

ğŸ§® Step 4: Time and Space Complexity
Operation	Complexity
Building Huffman tree	O(n log n)
Encoding traversal	O(n)
Total	O(n log n)
Space complexity	O(n) for storing the tree and codes

ğŸ“ Step 5: Viva Questions (with Answers)
Question	Answer
1ï¸âƒ£ What is Huffman Encoding?	A lossless data compression algorithm that assigns variable-length binary codes to characters based on their frequency.
2ï¸âƒ£ Which algorithmic strategy does it use?	Greedy Algorithm.
3ï¸âƒ£ What is the main idea behind Huffman Encoding?	Assign shorter codes to more frequent characters and longer codes to less frequent ones.
4ï¸âƒ£ What is the time complexity of Huffman Encoding?	O(n log n).
5ï¸âƒ£ What is the space complexity?	O(n).
6ï¸âƒ£ What data structure is used?	Min-Heap (Priority Queue).
7ï¸âƒ£ Where is Huffman used in real life?	File compression (ZIP), image compression (JPEG), text encoding.
8ï¸âƒ£ Is Huffman Encoding unique?	No, multiple trees can represent the same encoding cost, but total encoded length will be same.
9ï¸âƒ£ What happens if all frequencies are equal?	Then all codes will have the same length â€” no compression achieved.
ğŸ”Ÿ What is difference between prefix code and normal code?	Prefix codes ensure no code is prefix of another â€” used in Huffman encoding.

Perfect âœ… â€” letâ€™s do the same as before:
First, Iâ€™ll explain the complete theory of Fractional Knapsack Problem â€” step by step, with examples, greedy logic, formulas, complexity, and viva questions.
Then, once you fully understand it, weâ€™ll move on to Python and Java code.

ğŸ§  Practical 3: Fractional Knapsack Problem (Using Greedy Method)

ğŸ¯ Problem Statement
	Given a set of items, each with a weight and a value, determine the maximum value you can put in a knapsack (bag) of a fixed capacity W.
But hereâ€™s the twist:
ğŸ‘‰ You can break items into smaller parts â€” you can take a fraction of an item.
Thatâ€™s why itâ€™s called Fractional Knapsack.

ğŸ§© Real-Life Example
Imagine youâ€™re a thief who breaks into a jewelry shop ğŸ˜…
You have a bag that can carry W = 50 kg.
There are gold bars, diamonds, and silver coins â€” each with:
	â€¢ a weight
	â€¢ and a value
You can even take half a gold bar or quarter of a diamond if needed.
So your goal is to maximize the total value of items in your bag.

ğŸ“˜ Example
Item	Value	Weight	Value/Weight Ratio
1	60	10	6
2	100	20	5
3	120	30	4
Knapsack capacity = W = 50

Step 1ï¸âƒ£ â€” Calculate Value/Weight ratio
We already have:
Item 1: 6
Item 2: 5
Item 3: 4
Step 2ï¸âƒ£ â€” Sort items in descending order of Value/Weight
Order	Item	Ratio
1	Item 1	6
2	Item 2	5
3	Item 3	4

Step 3ï¸âƒ£ â€” Start filling the knapsack
ğŸª£ Capacity = 50
Step	Item	Weight Taken	Remaining Capacity	Value Added	Total Value
1	Item 1 (10kg)	10	40	60	60
2	Item 2 (20kg)	20	20	100	160
3	Item 3 (30kg)	Only 20 (fractional)	0	(20/30)*120 = 80	240
âœ… Maximum total value = 240

âš™ï¸ Step 4: Greedy Strategy
At every step:
	1. Choose the item with maximum (value/weight) ratio.
	2. Take as much as possible (whole or fractional) until the knapsack is full.
Thatâ€™s why itâ€™s called a Greedy Method â€”
you always choose the best local choice (max ratio) at each step.

ğŸ§® Step 5: Formula (if needed)
If you take a fraction x of an item:
[
\text{Total value} = \sum (x_i \times value_i)
]
where
[
0 â‰¤ x_i â‰¤ 1
]
and
[
\sum (x_i \times weight_i) â‰¤ W
]

â±ï¸ Step 6: Time and Space Complexity
Task	Complexity
Sorting items by ratio	O(n log n)
Selecting items	O(n)
Total Time	O(n log n)
Space	O(1) (or O(n) if using arrays)

ğŸ§® Step 7: Characteristics
Property	Description
Algorithm Type	Greedy
Fraction allowed?	âœ… Yes
Always optimal?	âœ… Yes
Data structure used	Array / List
Sorting criteria	Value/Weight ratio

ğŸ“˜ Step 8: Difference â€” Fractional vs 0/1 Knapsack
Feature	Fractional Knapsack	0/1 Knapsack
Fraction allowed?	âœ… Yes	âŒ No
Approach	Greedy	Dynamic Programming
Optimal for?	Fractional	Whole items only
Complexity	O(n log n)	O(nW)
Example	You can take half an apple	You must take or leave the apple

ğŸ“ Step 9: Viva Questions (with Answers)
Question	Answer
1ï¸âƒ£ What is the Knapsack Problem?	Itâ€™s an optimization problem where we aim to maximize total value under a weight constraint.
2ï¸âƒ£ What is the difference between 0/1 and Fractional Knapsack?	In fractional, we can take parts of items; in 0/1, we canâ€™t.
3ï¸âƒ£ What algorithmic technique is used in Fractional Knapsack?	Greedy Algorithm.
4ï¸âƒ£ What is the greedy choice here?	Selecting the item with the highest value/weight ratio.
5ï¸âƒ£ Is the greedy solution always optimal?	Yes, for the fractional case.
6ï¸âƒ£ What is time complexity?	O(n log n) due to sorting.
7ï¸âƒ£ Can we use this for 0/1 Knapsack?	No, greedy fails there.
8ï¸âƒ£ Why sorting is needed?	To pick items in descending order of value/weight ratio.
9ï¸âƒ£ What happens if all ratios are equal?	Any order will give the same result.
ğŸ”Ÿ Give one real-life example	Filling a fuel tank with different fuel grades or carrying valuable metals of different weights.

Perfect ğŸ‘
Letâ€™s follow the same approach: first the complete theory of 0/1 Knapsack Problem, step by step â€” including
concept, real-life example, working, formula, dynamic programming explanation, complexity, and viva questions.
After that, weâ€™ll do Python and Java codes with detailed explanations.

ğŸ§  Practical 4: 0/1 Knapsack Problem (Using Dynamic Programming)

ğŸ¯ Problem Statement
	Given n items, each with a weight and a value, find the maximum total value you can carry in a knapsack (bag) of capacity W.
But unlike the fractional version:
ğŸš« You cannot take fractions â€”
You either take the whole item (1) or leave it (0).
Thatâ€™s why itâ€™s called 0/1 Knapsack.

ğŸ§© Real-Life Example
Suppose you are going camping ğŸ’
You have a bag that can carry maximum weight = 50 kg.
There are several items (like food, clothes, tent, camera, etc.) â€” each has a weight and a value (usefulness).
You canâ€™t take half a tent or half a camera, right? ğŸ˜…
So, you have to choose the combination of whole items that gives the maximum total value.

ğŸ“˜ Example
Item	Value	Weight
1	60	10
2	100	20
3	120	30
Knapsack capacity, W = 50

ğŸ§® Step 1 â€” All Possible Combinations
You can take each item or not.
So for 3 items â†’ there are 2Â³ = 8 possibilities.
We want the maximum total value where the total weight â‰¤ W.
Possible selections:
Items Taken	Total Weight	Total Value
None	0	0
1	10	60
2	20	100
3	30	120
1, 2	30	160
1, 3	40	180
2, 3	50	220
1, 2, 3	60 âŒ	- (Exceeds 50)
âœ… So the best combination is items 2 and 3 â†’ Total Value = 220

âš™ï¸ Step 2 â€” Dynamic Programming Approach
Since checking all combinations is slow for large n (O(2^n)),
we use Dynamic Programming (DP) to optimize.
Idea:
We use a table dp[i][w] which stores the maximum value we can get
with the first i items and capacity w.

ğŸ§® Step 3 â€” DP Formula
For every item i and weight limit w:
[
dp[i][w] =
\begin{cases}
0 & \text{if } i=0 \text{ or } w=0 \
dp[i-1][w] & \text{if } weight[i] > w \
\max(value[i] + dp[i-1][w - weight[i]], dp[i-1][w]) & \text{otherwise}
\end{cases}
]

Explanation:
Term	Meaning
dp[i-1][w]	Value without taking current item
value[i] + dp[i-1][w - weight[i]]	Value if we take the item
max()	Choose whichever gives more value

ğŸ§¾ Step 4 â€” DP Table Example
i (items)	w=0	10	20	30	40	50
0	0	0	0	0	0	0
1	0	60	60	60	60	60
2	0	60	100	160	160	160
3	0	60	100	160	180	220
âœ… Maximum Value = 220

â±ï¸ Step 5 â€” Time and Space Complexity
Aspect	Complexity
Time	O(n Ã— W)
Space	O(n Ã— W) (can be optimized to O(W))

ğŸ§  Step 6 â€” Properties
Property	Description
Algorithm Type	Dynamic Programming
Fraction allowed?	âŒ No
Greedy works?	âŒ No
Optimal?	âœ… Yes
Approach	Bottom-Up (or Top-Down recursion + memoization)

ğŸ§© Step 7 â€” Branch and Bound (Alternative)
Another approach for 0/1 Knapsack is Branch and Bound, which is:
	â€¢ Based on backtracking
	â€¢ Explores decision tree (include/exclude items)
	â€¢ Uses upper bound to prune unpromising branches
(doesnâ€™t check every possibility)
But for academic and practical use â€” Dynamic Programming is preferred for implementation.

ğŸ“ Step 8 â€” Viva Questions (with Answers)
Question	Answer
1ï¸âƒ£ What is 0/1 Knapsack Problem?	Itâ€™s a problem where each item can be either taken fully (1) or left (0) to maximize value.
2ï¸âƒ£ What is the constraint?	The total weight must not exceed the given capacity.
3ï¸âƒ£ Why canâ€™t greedy algorithm be used here?	Because taking the item with best ratio may not always lead to the global optimum when fractions are not allowed.
4ï¸âƒ£ Which approach gives the optimal result?	Dynamic Programming.
5ï¸âƒ£ What is the state relation (formula)?	dp[i][w] = max(dp[i-1][w], value[i] + dp[i-1][w - weight[i]])
6ï¸âƒ£ What are base cases?	dp[0][w] = 0 and dp[i][0] = 0
7ï¸âƒ£ What is the time complexity?	O(n Ã— W)
8ï¸âƒ£ How can we reduce space complexity?	Use a 1D array of size W+1.
9ï¸âƒ£ Is the problem NP-hard?	Yes, it is NP-hard in general, but solvable using DP for smaller W.
ğŸ”Ÿ Give a real-world example	Selecting investment options or scheduling tasks with limited time/resources.

Perfect ğŸ‘‘
Letâ€™s do the complete theory explanation for the N-Queens Problem â€” just like we did for Knapsack:
Weâ€™ll cover the concept, real-life meaning, example, step-by-step logic, backtracking explanation, complexity, and viva Q&A.
Then after you fully understand it, weâ€™ll move to the Python and Java codes.

ğŸ§  Practical 5: N-Queens Problem (Using Backtracking)

ğŸ¯ Problem Statement
	Design an NÃ—N chessboard and place N queens such that no two queens attack each other.
The first queenâ€™s position is already given, and we need to place the remaining queens using a backtracking approach.

ğŸ° Understanding the Problem
	â€¢ A Queen in chess can move any number of squares:
		â—‹ Vertically
		â—‹ Horizontally
		â—‹ Diagonally
So, if two queens are placed on the same:
	â€¢ Row â†’ âŒ Attack possible
	â€¢ Column â†’ âŒ Attack possible
	â€¢ Diagonal â†’ âŒ Attack possible
Hence, we need to place all N queens such that none of these conflicts occur.

â™Ÿï¸ Example: 4 Queens Problem (N = 4)
We must place 4 queens on a 4Ã—4 board such that none attack each other.
A valid solution looks like:
. Q . .
. . . Q
Q . . .
. . Q .
or
. . Q .
Q . . .
. . . Q
. Q . .
Each â€œQâ€ is a queen, and â€œ.â€ means an empty square.
âœ… In both, no two queens share the same row, column, or diagonal.

ğŸ§© Step-by-Step Working (Concept)
	1. Start in the first column.
	2. Place the first queen in a safe row (if given, start there).
	3. Move to the next column.
	4. Try placing the next queen in a safe row:
		â—‹ If safe â†’ place it and move ahead.
		â—‹ If no safe position â†’ backtrack (remove the previous queen and try a new position).
	5. Continue until all queens are placed or no solution exists.

ğŸ” Backtracking Explained Simply
Backtracking means:
	â€œTry â†’ if it works, continue; if not, go back and try another possibility.â€
In N-Queens:
	â€¢ You try placing queens column by column.
	â€¢ If placing a queen causes a conflict later,
â†’ you go back (backtrack) to move it to a new safe spot.
Itâ€™s like exploring all possible configurations but efficiently rejecting wrong paths early.

ğŸ§® Example: 4-Queen Step Visualization
1ï¸âƒ£ Place Queen 1 at (Row 0, Col 0)
2ï¸âƒ£ Move to Column 1 â†’ No safe spot (since attacked by Queen 1 diagonally or horizontally).
â†’ Backtrack Queen 1 to (Row 1, Col 0).
3ï¸âƒ£ Try again until you find a configuration where all 4 queens are placed safely.
The recursive function explores every column and tries each possible row.

ğŸ§  Algorithm Steps (Backtracking)
1. Start with an empty board.
2. Place the first queen in the first column (given or chosen).
3. For each column:
   a. Try placing a queen in each row.
   b. If placing it is safe â†’ mark it and move to next column.
   c. If no row is safe â†’ backtrack (remove previous queen).
4. Repeat until all columns are filled.
5. Print the board when all queens are placed.


âš™ï¸ Safe Position Check (Core Logic)
To check if a queen can be safely placed at board[row][col]:
	1. Same Row Left Side â†’ No queen should be present.
	2. Upper Left Diagonal â†’ No queen on upper-left diagonal.
	3. Lower Left Diagonal â†’ No queen on lower-left diagonal.
We only check the left side, because queens are being placed column by column (right side is empty so far).

ğŸ§¾ Example Output (N = 4)
Solution 1:
. Q . .
. . . Q
Q . . .
. . Q .
Solution 2:
. . Q .
Q . . .
. . . Q
. Q . .

ğŸ§© Time and Space Complexity
Aspect	Complexity
Time	O(N!) â€” because we may explore all row placements
Space	O(NÂ²) â€” to store the board (or O(N) if optimized using arrays)

âš™ï¸ Problem Characteristics
Property	Description
Problem Type	Constraint Satisfaction
Technique Used	Backtracking
Deterministic?	Yes
Greedy Works?	âŒ No
Recursive?	âœ… Yes
Optimal Solution?	Not numerical â€” all valid configurations are acceptable

ğŸ’¡ Real-Life Analogy
Imagine arranging N people in N rooms,
but each person must not be in conflict (same row/column/diagonal).
You test one arrangement, and if someone conflicts, you adjust â€” this is backtracking.

ğŸ“ Viva Questions with Answers
Question	Answer
1ï¸âƒ£ What is the N-Queens problem?	Itâ€™s a problem of placing N queens on an NÃ—N chessboard so that no two queens attack each other.
2ï¸âƒ£ What is the condition for attacking?	Same row, same column, or diagonal.
3ï¸âƒ£ What algorithm is used?	Backtracking.
4ï¸âƒ£ What does backtracking mean?	Trying possible solutions recursively and undoing wrong ones.
5ï¸âƒ£ What is the time complexity?	O(N!).
6ï¸âƒ£ Why do we check only the left side?	Because we place queens column by column from left to right.
7ï¸âƒ£ Can greedy algorithm solve N-Queens?	No, because local choices donâ€™t lead to global solutions.
8ï¸âƒ£ What are base and recursive conditions?	Base â†’ all queens placed; Recursive â†’ try to place a queen safely in each column.
9ï¸âƒ£ How many solutions exist for N=4?	Two.
ğŸ”Ÿ What kind of problem is it?	A classic constraint satisfaction problem solved using backtracking.



